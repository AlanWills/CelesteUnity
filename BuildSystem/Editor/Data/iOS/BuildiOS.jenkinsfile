projectPath = ""
buildPath = ""

pipeline 
{
    agent {
		node {
			label 'built-in'
		}
	}
	options {
		skipDefaultCheckout()
	}
    environment 
    {
        UNITY_PATH = 'C:/Program Files/Unity/Hub/Editor/6000.2.7f2/Editor/Unity.exe'
		BRANCH = 'master'
    }
    stages 
    {
        stage('Setup Parameters') 
        {
            steps 
            {
                script 
                { 
                    properties([
                        buildDiscarder(
                            logRotator(
                                artifactDaysToKeepStr: '14', 
                                artifactNumToKeepStr: '1', 
                                numToKeepStr: '5')), 
                        parameters([
                            choice(choices: ['Debug', 'Release'], name: 'CONFIGURATION'), 
                            booleanParam(defaultValue: true, name: 'UPLOAD_BUILD_TO_TESTFLIGHT'), 
                            booleanParam(defaultValue: false, name: 'UPLOAD_ASSETS_TO_STORAGE')
                        ])
                    ])
                }
            }
        }
		stage('Clean Workspace') {
			steps {
				dir(env.WORKSPACE) {
					script {
						// fileExists works for both files and directories
						if (fileExists('.git')) {
							bat """
							git reset --hard HEAD
							git clean -fdx -e Library -e Assets/Settings/PlayMode -e Logs -e Temp -e UserSettings
							"""
						} else {
							echo "No .git directory found. Skipping cleanup."
						}
					}
				}
			}
		}
		stage('Checkout') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "${env.BRANCH}"]],
                    userRemoteConfigs: [[
                        url: 'git@github.com:AlanWills/Just-One.git',
                        credentialsId: 'Alan-SSH-Key'
                    ]],
                    extensions: [
						[$class: 'RelativeTargetDirectory', relativeTargetDir: '.'], // normal checkout
						[$class: 'LocalBranch', localBranch: "${env.BRANCH}"],
						[$class: 'SubmoduleOption', 
							recursiveSubmodules: true,        // clone submodules recursively
							trackingSubmodules: false,        // set to true if you want to track branches in submodules
							disableSubmodules: false,         // ensure submodules are not disabled
							parentCredentials: true           // use parent repo credentials for submodules
						]
					]
                ])
            }
        }
        stage('Build Unity Project')
        {
            steps
            {
                script
                {
                    buildName "iOS-" + CONFIGURATION
                    
                    methodToInvoke = "CelesteEditor.BuildSystem.BuildPlayer.Build" + params.CONFIGURATION + "iOSPlayer"
                    projectPath = "\"${env.WORKSPACE.replace('\\','/')}\""
					def unityCommand = "\"${env.UNITY_PATH}\" -quit -batchmode -nographics -executeMethod ${methodToInvoke} -projectPath ${projectPath}"

					echo "Executing Unity Build Command: ${unityCommand}"
					bat unityCommand

                    readProperties(file: "${env.WORKSPACE}/Library/BUILD_ENV_VARS.txt").each {key, value -> env[key] = value }
					
					buildPath = "${projectPath}/${env.BUILD_LOCATION}"
                    buildName "iOS-" + CONFIGURATION + "-" + env.BUILD_VERSION
                    
                    readProperties(file: "${env.WORKSPACE}/Library/ASSETS_ENV_VARS.txt").each {key, value -> env[key] = value }
                }
            }
        }
		stage('Copy iOS Project To Temp Directory')
		{
			when
            {
                expression
                {
                    return currentBuild.currentResult == "SUCCESS" && env.USE_TEMP_DIRECTORY == 'True'
                }
            }
			steps
			{
				script
				{
					def tempBuildPath = "${env.TEMP_DIRECTORY_PATH}/Build-${env.BUILD_VERSION}-${params.CONFIGURATION}"
					def deleteCommand = "/usr/bin/find ${env.TEMP_DIRECTORY_PATH}/* -not -path " + '"' + "${env.TEMP_DIRECTORY_PATH}/builder*" + '" -prune -exec rm -rf {} \\;'
					
					echo "${deleteCommand}"
					sh "${deleteCommand}"
					sh "cp -r ${projectPath}/${env.BUILD_LOCATION} ${tempBuildPath}"
					buildPath = tempBuildPath
				}
			}
		}
        stage('Build iOS Project') {
			when {
				expression { return currentBuild.currentResult == null || currentBuild.currentResult == "SUCCESS" }
			}
			steps {
				script {
					// 1. Define your paths (using forward slashes for safety)
					def tool = "${env.IOS_PROJECT_BUILDER_INSTALL_PATH}/build.cmd"
					def sdk = "${env.IOS_PROJECT_BUILDER_INSTALL_PATH}/SDK-iOS"
					def identity = "${env.DISTRIBUTION_CERTIFICATE}:${env.PRIVATE_KEY}:${env.PRIVATE_KEY_PASSWORD}"
					def provision = "${env.PROVISIONING_PROFILE}"

					// 2. Use the dir block to change the working directory
					dir(buildPath) {
						echo "Current working directory is now: ${pwd()}"
						
						// Since we are now INSIDE buildPath, we can use "." to refer to the current folder
						def buildCmd = "\"${tool}\" -xcname \"Unity-iPhone\" -xcpname \"Unity-iPhone\" -xcconf \"Release\" -sdk \"${sdk}\" -archs arm64 -multicore -lld -pngcrush -ipa -identity \"${identity}\" -provision \"${provision}\""
						
						echo "Running build command: ${buildCmd}"
						bat "${buildCmd}"
					}
				}
			}
		}
		stage('Copy .ipa From Temp Directory')
		{
			when
            {
                expression
                {
                    return currentBuild.currentResult == "SUCCESS" && env.USE_TEMP_DIRECTORY == 'True'
                }
            }
			steps
            {
				script
				{
					sh "cp -r ${buildPath}/Packages ${projectPath}/${env.BUILD_LOCATION}/Packages"
				}
            }
		}
        stage('Commit Version')
        {
            when
            {
                expression
                {
                    return currentBuild.currentResult == "SUCCESS"
                }
            }
            steps
            {
                sh "git add ."
                sh 'git commit --allow-empty -m "Built iOS and updating version"'
				sh "git pull origin ${env.BRANCH} --rebase"
                sh "git push --set-upstream origin ${env.BRANCH}"
            }
        }
		stage('Artifact Build')
		{
			steps 
			{
				archiveArtifacts artifacts: "${env.BUILD_LOCATION}/Packages/${env.IPA_NAME}.ipa", onlyIfSuccessful: true
			}
		}
		stage('Artifact Assets')
		{
			steps 
			{
				archiveArtifacts artifacts: "${env.ASSETS_SOURCE}/*.*", onlyIfSuccessful: true
			}
		}
        stage('Upload Build To Test Flight')
        {
            when
            {
                expression
                {
                    return currentBuild.currentResult == "SUCCESS" && params.UPLOAD_BUILD_TO_TESTFLIGHT
                }
            }
            steps
            {
				script
				{
					def uploadTool   = "${env.IOS_PROJECT_BUILDER_INSTALL_PATH}/upload.cmd"
					def ipaPath      = "${buildPath}/Packages/${env.IPA_NAME}.ipa"
					def identity     = "${env.DISTRIBUTION_CERTIFICATE}:${env.PRIVATE_KEY}:${env.PRIVATE_KEY_PASSWORD}"
					def provision    = "${env.PROVISIONING_PROFILE}"
					def user         = env.ASC_USERNAME
					def password     = env.ASC_PASSWORD
					def packagesPath = "${buildPath}/Packages"
					
					// 2. Use the dir block to change the working directory
					dir(packagesPath) {
						echo "Current working directory is now: ${pwd()}"
						
						def uploadCmd = "\"${uploadTool}\" -identity \"${identity}\" -entitlements \"\" -artwork \"\" -provision \"${provision}\" -v \"${ipaPath}\" -asclogin ${user} -ascpassword ${password} -ascprovider \"\""
						
						echo "Running upload command: ${uploadCmd}"
						bat "${uploadCmd}"
					}
				}
            }
        }
        stage('Upload Assets To Storage')
        {
            when
            {
                expression
                {
                    return currentBuild.currentResult == "SUCCESS" && params.UPLOAD_ASSETS_TO_STORAGE
                }
            }
            steps
            {
                googleStorageUpload bucket: "gs://${env.ASSETS_DESTINATION}", credentialsId: "${env.ASSETS_UPLOAD_CREDENTIALS}", pattern: "${env.ASSETS_SOURCE}/*"
                sh "rm -r ${env.ASSETS_SOURCE}"
            }
        }
    }   
}